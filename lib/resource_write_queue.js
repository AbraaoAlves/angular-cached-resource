// Generated by CoffeeScript 1.7.1
var CACHE_RETRY_TIMEOUT;

CACHE_RETRY_TIMEOUT = 60000;

module.exports = function(debug) {
  var Cache, ResourceCacheEntry, ResourceWriteQueue;
  ResourceCacheEntry = require('./resource_cache_entry')(debug);
  Cache = require('./cache')(debug);
  return ResourceWriteQueue = (function() {
    ResourceWriteQueue.prototype.logStatusOfRequest = function(status, action, params, data) {
      return debug("ngCachedResource", "" + action + " for " + this.key + " " + (angular.toJson(params)) + " " + status, data);
    };

    function ResourceWriteQueue(CachedResource, $timeout) {
      this.CachedResource = CachedResource;
      this.$timeout = $timeout;
      this.key = "" + this.CachedResource.$key + "/write";
      this.queue = Cache.getItem(this.key, []);
      this.count = 0;
    }

    ResourceWriteQueue.prototype.enqueue = function(params, resourceData, action, deferred) {
      var resourceParams, write, _ref, _ref1;
      this.logStatusOfRequest('enqueued', action, params, resourceData);
      resourceParams = angular.isArray(resourceData) ? resourceData.map(function(resource) {
        return resource.$params();
      }) : resourceData.$params();
      write = this.findWrite({
        params: params,
        action: action
      });
      if (write == null) {
        this.queue.push({
          params: params,
          resourceParams: resourceParams,
          action: action,
          deferred: deferred
        });
        return this._update();
      } else {
        if ((_ref = write.deferred) != null) {
          _ref.promise.then(function(response) {
            return deferred.resolve(response);
          });
        }
        return (_ref1 = write.deferred) != null ? _ref1.promise["catch"](function(error) {
          return deferred.reject(error);
        }) : void 0;
      }
    };

    ResourceWriteQueue.prototype.findWrite = function(_arg) {
      var action, params, write, _i, _len, _ref;
      action = _arg.action, params = _arg.params;
      _ref = this.queue;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        write = _ref[_i];
        if (action === write.action && angular.equals(params, write.params)) {
          return write;
        }
      }
    };

    ResourceWriteQueue.prototype.removeWrite = function(_arg) {
      var action, entry, newQueue, params, _i, _len, _ref;
      action = _arg.action, params = _arg.params;
      newQueue = [];
      _ref = this.queue;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entry = _ref[_i];
        if (!(action === entry.action && angular.equals(params, entry.params))) {
          newQueue.push(entry);
        }
      }
      this.queue = newQueue;
      if (this.queue.length === 0 && this.timeoutPromise) {
        this.$timeout.cancel(this.timeoutPromise);
        delete this.timeoutPromise;
      }
      return this._update();
    };

    ResourceWriteQueue.prototype.flush = function() {
      var write, _i, _len, _ref, _results;
      this._setFlushTimeout();
      _ref = this.queue;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        write = _ref[_i];
        _results.push(this._processWrite(write));
      }
      return _results;
    };

    ResourceWriteQueue.prototype.processResource = function(params, done) {
      var notDone, write, _i, _len, _ref, _results;
      notDone = true;
      _ref = this._writesForResource(params);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        write = _ref[_i];
        _results.push(this._processWrite(write, (function(_this) {
          return function() {
            if (notDone && _this._writesForResource(params).length === 0) {
              notDone = false;
              return done();
            }
          };
        })(this)));
      }
      return _results;
    };

    ResourceWriteQueue.prototype._writesForResource = function(params) {
      var write, _i, _len, _ref, _results;
      _ref = this.queue;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        write = _ref[_i];
        if (angular.equals(params, write.params)) {
          _results.push(write);
        }
      }
      return _results;
    };

    ResourceWriteQueue.prototype._processWrite = function(write, done) {
      var cacheEntries, onFailure, onSuccess, writeData;
      if (angular.isArray(write.resourceParams)) {
        cacheEntries = write.resourceParams.map((function(_this) {
          return function(resourceParams) {
            return new ResourceCacheEntry(_this.CachedResource.$key, resourceParams).load();
          };
        })(this));
        writeData = cacheEntries.map(function(cacheEntry) {
          return cacheEntry.value;
        });
      } else {
        cacheEntries = [new ResourceCacheEntry(this.CachedResource.$key, write.resourceParams).load()];
        writeData = cacheEntries[0].value;
      }
      this.logStatusOfRequest('processed', write.action, write.resourceParams, writeData);
      onSuccess = (function(_this) {
        return function(value) {
          var cacheEntry, _i, _len, _ref;
          _this.logStatusOfRequest('succeeded', write.action, write.resourceParams, writeData);
          _this.removeWrite(write);
          for (_i = 0, _len = cacheEntries.length; _i < _len; _i++) {
            cacheEntry = cacheEntries[_i];
            cacheEntry.setClean();
          }
          if ((_ref = write.deferred) != null) {
            _ref.resolve(value);
          }
          if (angular.isFunction(done)) {
            return done();
          }
        };
      })(this);
      onFailure = (function(_this) {
        return function(error) {
          var _ref;
          if (error && error.status >= 400 && error.status < 500) {
            _this.removeWrite(write);
            _this.logStatusOfRequest("failed with error " + (angular.toJson(error)) + "; removed from queue", write.action, write.resourceParams, writeData);
          } else {
            _this.logStatusOfRequest("failed with error " + (angular.toJson(error)) + "; still in queue", write.action, write.resourceParams, writeData);
          }
          return (_ref = write.deferred) != null ? _ref.reject(error) : void 0;
        };
      })(this);
      return this.CachedResource.$resource[write.action](write.params, writeData, onSuccess, onFailure);
    };

    ResourceWriteQueue.prototype._setFlushTimeout = function() {
      if (this.queue.length > 0 && !this.timeoutPromise) {
        this.timeoutPromise = this.$timeout(angular.bind(this, this.flush), CACHE_RETRY_TIMEOUT);
        return this.timeoutPromise.then((function(_this) {
          return function() {
            delete _this.timeoutPromise;
            return _this._setFlushTimeout();
          };
        })(this));
      }
    };

    ResourceWriteQueue.prototype._update = function() {
      var savableQueue;
      savableQueue = this.queue.map(function(write) {
        return {
          params: write.params,
          resourceParams: write.resourceParams,
          action: write.action
        };
      });
      Cache.setItem(this.key, savableQueue);
      return this.count = savableQueue.length;
    };

    return ResourceWriteQueue;

  })();
};
