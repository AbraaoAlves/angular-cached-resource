// Generated by CoffeeScript 1.7.1
var processReadArgs, readArrayCache,
  __slice = [].slice;

processReadArgs = require('./process_read_args');

module.exports = readArrayCache = function($q, log, name, CachedResource) {
  var ResourceCacheArrayEntry, ResourceCacheEntry;
  ResourceCacheEntry = require('./resource_cache_entry')(log);
  ResourceCacheArrayEntry = require('./resource_cache_array_entry')(log);
  return function() {
    var arrayInstance, cacheArrayEntry, cacheDeferred, cacheInstanceEntry, cacheInstanceParams, httpDeferred, params, readHttp, _i, _len, _ref, _ref1;
    _ref = processReadArgs($q, arguments), params = _ref.params, cacheDeferred = _ref.deferred;
    httpDeferred = $q.defer();
    arrayInstance = new Array();
    arrayInstance.$promise = cacheDeferred.promise;
    arrayInstance.$httpPromise = httpDeferred.promise;
    cacheArrayEntry = new ResourceCacheArrayEntry(CachedResource.$key, params).load();
    arrayInstance.$httpPromise.then(function(response) {
      var cacheArrayReferences, cacheInstanceEntry, cacheInstanceParams, instance, _i, _len;
      cacheArrayReferences = [];
      for (_i = 0, _len = response.length; _i < _len; _i++) {
        instance = response[_i];
        cacheInstanceParams = instance.$params();
        if (Object.keys(cacheInstanceParams).length === 0) {
          log.error("instance " + instance + " doesn't have any boundParams. Please, make sure you specified them in your resource's initialization, f.e. `{id: \"@id\"}`, or it won't be cached.");
        } else {
          cacheArrayReferences.push(cacheInstanceParams);
          cacheInstanceEntry = new ResourceCacheEntry(CachedResource.$key, cacheInstanceParams).load();
          cacheInstanceEntry.set(instance, false);
        }
      }
      return cacheArrayEntry.set(cacheArrayReferences);
    });
    readHttp = function() {
      var resource;
      resource = CachedResource.$resource[name](params);
      resource.$promise.then(function() {
        var cachedResourceInstances;
        cachedResourceInstances = resource.map(function(resourceInstance) {
          return new CachedResource(resourceInstance);
        });
        arrayInstance.splice.apply(arrayInstance, [0, arrayInstance.length].concat(__slice.call(cachedResourceInstances)));
        if (!cacheArrayEntry.value) {
          cacheDeferred.resolve(arrayInstance);
        }
        return httpDeferred.resolve(arrayInstance);
      });
      return resource.$promise["catch"](function(error) {
        if (!cacheArrayEntry.value) {
          cacheDeferred.reject(error);
        }
        return httpDeferred.reject(error);
      });
    };
    if (CachedResource.$writes.count > 0) {
      CachedResource.$writes.flush(readHttp);
    } else {
      readHttp();
    }
    if (cacheArrayEntry.value) {
      _ref1 = cacheArrayEntry.value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        cacheInstanceParams = _ref1[_i];
        cacheInstanceEntry = new ResourceCacheEntry(CachedResource.$key, cacheInstanceParams).load();
        arrayInstance.push(new CachedResource(cacheInstanceEntry.value));
      }
      cacheDeferred.resolve(arrayInstance);
    }
    return arrayInstance;
  };
};
